# DDD

参考（从入门到深入）：

+ [DDD专题-小傅哥](https://bugstack.cn/md/develop/framework/ddd/2019-10-15-DDD%E4%B8%93%E9%A2%98%E6%A1%88%E4%BE%8B%E4%B8%80%E3%80%8A%E5%88%9D%E8%AF%86%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1DDD%E8%90%BD%E5%9C%B0%E3%80%8B.html)

+ [DDD架构-小傅哥](https://bugstack.cn/md/road-map/ddd.html)

+ [MVC2DDD-架构重构](https://bugstack.cn/md/road-map/mvc2ddd.html)

+ [awesome-ddd](https://github.com/heynickc/awesome-ddd)

  包括一些书籍、课程、博客、示例项目。

+ 《中台架构与实现，基于DDD和微服务》C5-C11

  先看前面的网页资料，有个大概的认识，最好看看DDD示例代码的结构，然后看这本书会更容易。

  这本书最大的问题是没有提供完整的源码（只有第19章的一个简陋的案例），书上描述的DDD和小傅哥的DDD在分层结构和依赖关系上还是有一些出入的。

+ 《实现领域驱动设计》

+ 《领域驱动设计》



## 基本概念

+ **领域**

  即某个业务独有的所有的数据、规则和行为称为这个业务的领域；领域包含**领域服务**、**领域对象**（实体、聚合、值对象）、**仓储服务接口**、**事件**、**适配器**等；

  领域对外提供服务通过领域服务接口。

  领域下的分包（package）方式：

  + 领域多的场景

    ```shell
    /s1 # 某个领域
    	/model 	# 领域对象
            /aggregates
            /entity
            /valobj
    	/port	# 调用外部接口，包名或者叫做 adapter
        /repository
        /service
        /factory
        /exception
    /s2
    ```

  + 领域少的场景

    ```shell
    /model 	# 领域对象
    	/aggregates
    	/entity
    		/s1	# 某个领域的实体
    		/s2
    	/valobj
    /port	# 调用外部接口，包名或者叫做 adapter
    /repository
    /service
    	/s1	# 某个领域的服务
        /s2
    /factory
    /exception
    ```

+ **子域**

  领域也可以继续拆分成多个子域，比如活动领域，里面可能包含抽奖领域、返利领域。

  + 核心子域
  + 通用子域
  + 支撑子域

+ **限界上下文**

  领域的划分生成限界上下文，这个概念有点抽象，也不会在代码中体现出来；

  限界上下文限定什么内容应该在这个领域模型中实现，什么不应该在这个领域模型中实现，比如你定义了一个电商支付领域，那么就定义了一个支付服务的限界上下文，支付行为就应该在支付领域中定义，而不能在其他服务领域中定义。

+ 通用语言

+ **领域对象**

  + **实体（Entity）**

    包含**唯一标识符**（比如各种ID），是业务形态的业务对象（BO），集多个业务属性、操作、或行为于一体，是一个属性集合。

    一个实体对象可能对应**0、1或多个数据库持久化对象**（**PO**）。

    比如：Mybatis联表查询，查询用户角色实体对象（UserRoleEntity），包含用户 UserPO 和角色 RolePO 两个持久化对象的属性（**不要求所有属性, 比如有时不需要PO对象中的 createTime updateTime 这类属性**）。

    实体属于领域层。

  + **值对象**

    本质也是一个**属性集合**，不过**不包含唯一标识符**，且是**不可变对象**，内部属性和实体一样可以部分包含PO属性；

    比如：一个人员Person 实体，包含用户ID、姓名、年龄、性别等 User 持久化对象的部分属性，还包括 省、市、区等 Address 持久化对象的部分属性；

    Person 类定义时常常会将上面的Address属性定义为一个**值对象**进行包含，而不是直接将Address的属性平铺到Person类中。

    值对象属于领域层。

  + **聚合、聚合根**

    聚合是由**业务和逻辑紧密关联的实体和值对象组合**而成的；

    聚合根是聚合中的实体，又称根实体，聚合根可以解决聚合中实体和值对象的之间的数据不一致的情况，怎么做？

    聚合属于领域层。


+ **仓储服务接口**

  领域获取外部数据的接口，比如数据库（DAO）、缓存、Redis、ES、配置（本地配置、配置中心）等。

  仓储服务接口实现属于基础设施层。

+ **适配器**

  比如支付领域服务调用第三方支付接口，通过在支付领域定义适配器实现调用。

  适配器适配的接口属于基础设施层。

+ **领域编排**

  用于串联业务涉及的各个领域提供一个完整的服务链路。

  领域编排可以在**应用服务**（xxx-case）中实现。

+ **触发器**

  业务串联好后，通过触发器模块为外部提供接口（HTTP、RPC、事件订阅、消息监听、定时任务等）。

+ **事件风暴**（**四色建模**）

  即穷举领域中的**动作**或**事件**，比如电商领域的商品下单（动作）、订单支付（动作）、订单已支付（事件）等。

  通过先穷举领域中的动作或事件，然后分类、整理出实体、值对象、聚合、聚合根、领域。

  如《中台架构与实现》中表 6-1。

  事件风暴过程中需要绘制 **用例图 -> 流程图 -> 定义领域对象 -> 划分领域 -> 定义上下文边界**。

  + **领域事件**


+ **充血模型与贫血模型**

  充血模型强调将业务逻辑封装到自己的领域对象中（不限制某一个对象）； 
  贫血模型强调将数据与行为分离，其中数据由对象持有，而行为则由外部服务提供。

  但是充血模型不限于将行为封装到某个对象，只要将行为封装到自己领域的包下，一样属于充血模型，比如某个服务所在领域包中包含这个服务需要使用的各种模型对象、仓储、工厂类，也视为**充血模型**。

+ DDD架构

  定义 DDD 分层和依赖关系。

  + **洋葱架构**

    领域模型作为核心，依赖顺序： 用户界面/基础设施   -> 应用服务 -> 领域服务 -> 领域模型。

  + **六边行架构**

    通过适配器与外部交互（向外部提供接口、发起外部调用）

  + **菱形架构**

    对六边行架构的优化。

  所有 DDD 架构领域模型都作为核心模块，不依赖其他模块而是被其他模块依赖，领域模型如果需要调用基础架构层功能，则是通过依赖倒置实现（**适配器**），即领域模型定义接口（规范），基础架构层实现接口，关于依赖导致像 Servlet、JDBC 等都属于依赖导致。

## 三层架构 vs DDD

有些地方拿 MVC 和 DDD 比较，说的 MVC 其实是说的三层架构；

如果项目逻辑复杂功能点很多，Service 层会包含很多东西，依赖很多其他服务组件，会显得臃肿，做微服务拆分时，很困难；
而 DDD 以领域进行划分，不属于自己领域的东西不会定义，结构清晰，且在做微服务拆分时会很容易。

另外随着代码迭代三层架构模式，一个逻辑的代码很分散，不方便开发和维护。

## 分层结构

架构分层规定项目的模块组成，领域分层决定领域服务内部软件包（如package）组成。

这里对比下小傅哥的DDD（有改动的**六边行架构**）和《中台架构与实现，基于DDD和微服务》书上DDD的差异。

**架构分层**（小傅哥）：

![](https://bugstack.cn/images/roadmap/tutorial/road-map-230624-03.png?raw=true)

- **接口定义 - xfg-frame-api**：因为微服务中引用的 RPC 需要对外提供接口的描述信息，也就是调用方在使用的时候，需要引入 Jar 包，让调用方好能依赖接口的定义做代理。

- **应用封装 - xfg-frame-app**：这是应用启动和配置的一层，如一些 aop 切面或者 config 配置，以及打包镜像都是在这一层处理。你可以把它理解为专门为了启动服务而存在的。

- **领域封装 - xfg-frame-domain**：领域模型服务，是一个非常重要的模块。无论怎么做DDD的分层架构，domain 都是肯定存在的。在一层中会有一个个细分的领域服务，在每个服务包中会有【模型、仓库、服务】这样3部分。

- **仓储服务 - xfg-frame-infrastructure**：基础层依赖于 domain 领域层，因为在 domain 层定义了仓储接口需要在基础层实现。这是依赖倒置的一种设计方式。

  > 依赖倒置：领域层需要调用基础层的的仓库接口，但是仓库接口API放在领域层中定义，实现基础层反过来依赖领域层。
  >
  > 像JDK中提供的一些 DataSource、Servlet API  都是依赖倒置。

- **领域封装 - xfg-frame-trigger**：触发器层，一般也被叫做 adapter 适配器层。用于提供接口实现、消息接收、任务执行等。所以对于这样的操作，小傅哥把它叫做触发器层。

- **类型定义 - xfg-frame-types**：通用类型定义层，在我们的系统开发中，会有很多类型的定义，包括；基本的 Response、Constants 和枚举。它会被其他的层进行引用使用。

- **领域编排【可选】 - xfg-frame-case**：领域编排层，一般对于较大且复杂的的项目，为了更好的防腐和提供通用的服务，一般会添加 case/application 层，用于对 domain 领域的逻辑进行封装组合处理。

> xfg-frame-trigger关于触发器层的定义，个人比较认同将接口（HTTP、RPC）、MQ、定时任务放在这一层，因为这么做程序的逻辑入口比较清晰，首次接收项目梳理业务逻辑或者后面回顾业务逻辑时只需要去这一层寻找逻辑入口即可。

**架构分层**（中台架构与实现）：

+ **用户接口层**

  借助 facade服务、数据组装器 Assembler 面向前端提供灵活的适配能力，保证应用层和领域层核心领域逻辑稳定；

  对应上面的**适配器层**；

+ **应用层**

  是很薄的一层，主要用于协调领域层多个聚合完成服务的组合和编排（通过提供应用服务的方式）；

  对应上面的 (**应用封装 + 领域编排**)；

  在应用层主要有应用服务、事件订阅和发布等相关逻辑代码；

  在应用服务中还可以进行**安全认证、权限校验、事务控制、领域事件的发布和订阅**；

  > 为了防止事务控制嵌套，领域层统一不加事务控制，事务控制全部放在应用层的应用服务中。

+ **领域层**

+ **基础层**

  主要用于为其他层提供通用的技术和基础服务，包括第三方工具、驱动、消息中间件、网关、文件、缓存以及数据库，最常用的功能是完成实体的数据库持久化。

  > 第三方工具放在基础层，领域层中要使用怎么办？
  >
  > 像小傅哥的DDD可以将第3方工具放入**通用类型定义层（types）**解决。

**分层之间的依赖关系**：

<img src="../../imgs/DDD分层对比.png"  />

两者的领域层均处于核心依赖位置；

两者适配器层（用户接口层）、领域层的职能基本相同，应用层和基础层有较大差异；小傅哥的应用层包含了一些中间件的配置，即有中台架构与实现的DDD的基础层的部分职能；

> 不明白中台架构与实现中为何将基础层作为最重的一层？个人感觉小傅哥的分层依赖关系更合理，也更符合直觉。

**分层之间调用关系**：

小傅哥的DDD:

trigger -> app -> domain -> infrastructure

中台架构与实现的DDD:

interfaces -> app -> domain -> infrastructure

> 结合前面的依赖关系：
>
> 小傅哥的DDD除了基础层和领域层、适配器层调用应用层也需要使用依赖倒置；中台架构与实现的DDD只需要基础层和领域层使用依赖倒置。

**领域层实现**：

介绍 domain 模块的分包和工作流程。

![](https://bugstack.cn/images/roadmap/tutorial/roadmap-ddd-01.png?raw=true)



## 分层中的各种对象类型的转换

比如DTO、实体对象、值对象、聚合对象、PO 等在DDD中是怎么转换的？



